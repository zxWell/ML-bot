const fs = require('fs');
const FS = fs.promises;
const express = require('express');
const fetch = require('node-fetch');
const bodyParser = require('body-parser');
function isObject(object) { //Проверяет является ли что-то объектом
    if(
        Array.isArray(object) || 
        typeof object !== 'object'
    ) return false;
    if(typeof object == 'object') return true;
}
function _delete(copy, origin) { //Удаляет все ключи с "_" и возвращает новый объект
    for (const key in origin) {
        if(key.slice(0,1) !== "_"&& key!=="ServerAPI"&& key!=="ClientAPI") {
            copy[key] = origin[key];
            if(isObject(origin[key])) _delete(copy[key], origin[key]);
        }
    }
}
function getData(url) {
    return new Promise(async (resolve, reject) => {
        fetch(url)
        .catch(err=>reject(err))
        .then(async response=> {
            if(!response) reject(new Error("The request failed"));
            resolve(await response?.json());
        });
    });
}
function isFunction(fnc)  {
    let getType = {};
    return fnc && getType.toString.call(fnc) === '[object Function]';
}
function stringToFunction(fun) {
    return new Function(
        fun.toString().slice(fun.toString().indexOf("(")+1,fun.toString().indexOf(")")).split(","), 
        fun.toString().slice(fun.toString().indexOf("{")+1,fun.toString().lastIndexOf("}"))
    );
}
function UpdateCreate(origin, data) { //Устанавливает ключи если их нет
    for (const key in data) {
        if(key.slice(0,1)!=="_") {
            if(origin[key] === undefined) origin[key] = data[key];
            else if(isObject(data[key]) && key!=="members") UpdateCreate(origin[key], data[key]);
        }
        
    }
}
function UpdateDelete(origin, data) { //Удаляет ключи если их быть не должно
    for (const key in origin) {
        if(key.slice(0,1)!=="_") {
            if(data[key] === undefined) delete origin[key];
            else if(isObject(origin[key]) && key!=="members") UpdateDelete(origin[key], data[key]);
        }

    }
}
function UpdateCacheAPI(data, old) {
    delete data._oldData;
    delete data.members;
    const out = {};
    for (const key in old) {
        if(data[key] !== old[key]) out[key]=data[key];
        if(data[key] === undefined) out[key]="ReMoVeAPI";
        else if(isObject(old[key])) UpdateCacheAPI(data[key], old[key]);
    }
    for (const key in data) {
        if(data[key] !== old[key]) out[key]=data[key];
        else if(isObject(data[key])) UpdateCacheAPI(data[key], old[key]);
    }
    return out;
}
function UpdateSendDataType(data) {
    for (const key in data) {
        if(isObject(data[key])) data[key] = "DDT-"+JSON.stringify(data[key]);
        else if(typeof data[key] == 'number') data[key] = "NUM-"+data[key];
        else if(typeof data[key] !== 'string') data[key] = "DDT-"+JSON.stringify(data[key]);
    }
    return data;
}

const globals = {
    name: "ANY",
    bot: {}
};
class ServerAPI {
    constructor(Memory, passwd) {
        this.Memory = Memory;
        const app = express();
        this.app = app;
        app.use(bodyParser.json());
        app.use(bodyParser.urlencoded({
            extended: true,
        }));
        this.app.get('/', (request, response) => {
            response.send({
                st: true,
                message: "О, привет!"
            });
        });
        this.app.get('/get', (request, response) => {
            console.log(request.query);
            if(request.query.passwd !== passwd) return response.send({message: null});
            if(request.query.userId) return response.send(Memory.users.get(request.query.userId)||{message: null});
            if(request.query.memberId && request.query.guildId) return response.send(Memory.guilds.get(request.query.guildId)?.members?.get(request.query.memberId)||{message: null});
            if(request.query.guildId) return response.send(Memory.guilds.get(request.query.guildId)||{message: null});
            response.send({
                message: null
            });
        });
        this.app.get('/push', (request, response) => {
            if(request.query.passwd !== passwd) return response.send({message: null});
            for (const key in request.query) {
                if(request.query[key]?.slice(0,4)=="NUM-") request.query[key] = +request.query[key].slice(4);
                if(request.query[key].slice && request.query[key].slice(0,4)=="DDT-") request.query[key] = JSON.parse(request.query[key].slice(4));
            }
            if(request.query.userId) {
                const user = Memory.users.get(request.query.userId);
                delete request.query.userId;
                if(!user) return response.send({message: false});
                for (const key in request.query) {
                    if(request.query[key]=="ReMoVeAPI") return delete user[key];
                    user[key]=request.query[key];
                }
                return response.send({message: true});
            } 
            if(request.query.memberId && request.query.guildId) {
                const member = Memory.guilds.get(request.query.guildId)?.members?.get(request.query.memberId);
                delete request.query.memberId;
                delete request.query.guildId;
                if(!member) return response.send({message: false});
                for (const key in request.query) {
                    if(request.query[key]=="ReMoVeAPI") return delete member[key];
                    member[key]=request.query[key];
                }
                return response.send({message: true});
            }
            if(request.query.guildId) {
                const guild = Memory.guilds.get(request.query.guildId);
                delete request.query.guildId;
                if(!guild) return response.send({message: false});
                for (const key in request.query) {
                    if(request.query[key]=="ReMoVeAPI") return delete guild[key];
                    guild[key]=request.query[key];
                }
                return response.send({message: true});
            }
            response.send({
                message: false
            });
        });
    }
    start(port) {
        return new Promise(async (resolve, reject) => {
            this.server = this.app.listen(port, (error) => {
                if (error) return reject(error);
                return resolve(this.server.address().port);
            });
        });
        
    }
    stop() {
        this.server.close();
    }
}
class ClientAPI {
    constructor(ip, port, passwd) {
        this.ip = `http://`+ip;
        this.port = port;
        passwd = "&passwd="+passwd;

        class MembersAPI {
            constructor(url, guildId) {
                this._url = url;
                this._guildId = guildId;
                this._MemberAPI = class MemberAPI {
                    constructor(data) {
                        for (const key in data) this[key] = data[key];
                        this._oldData = data;
                    }
                    async save() {
                        const data = UpdateSendDataType(UpdateCacheAPI(this, this._oldData));
                        let sendText = "";
                        for (const key in data) {
                            sendText+="&"+key+"="+data[key];
                        }
                        return await getData(url+"/push?guildId="+guildId+"&memberId="+this.id+sendText+passwd||"");
                    }
                    
                };
            }
            async get(id) {
                const data = await getData(this._url+"/get?guildId="+this._guildId+"&memberId="+id+passwd||"");
                if(data.message === null) return null;
                return new this._MemberAPI(data);
            }
        }
        class GuildsAPI {
            constructor(url) {
                this._url = url;
                this._GuildAPI = class GuildAPI {
                    constructor(data) {
                        for (const key in data) this[key] = data[key];
                        this._oldData = data;
                        this.members = new MembersAPI(url, this.id);
                    }
                    async save() {
                        const data = UpdateSendDataType(UpdateCacheAPI(this, this._oldData));
                        let sendText = "";
                        for (const key in data) {
                            sendText+="&"+key+"="+data[key];
                        }
                        return await getData(url+"/push?guildId="+this.id+sendText+passwd||"");
                    }
                    
                };
            }
            async get(id) {
                const data = await getData(this._url+"/get?guildId="+id+passwd||"");
                if(data.message === null) return null;
                delete data._members;
                return new this._GuildAPI(data);
            }
        }
        class UsersAPI {
            constructor(url) {
                this._url = url;
                this._UserAPI = class UserAPI {
                    constructor(data) {
                        for (const key in data) this[key] = data[key];
                        this._oldData = data;
                    }
                    async save() {
                        const data = UpdateSendDataType(UpdateCacheAPI(this, this._oldData));
                        let sendText = "";
                        for (const key in data) {
                            sendText+="&"+key+"="+data[key];
                        }
                        return await getData(url+"/push?userId="+this.id+sendText+passwd||"");
                    }
                    
                };
            }
            async get(id) {
                const data = await getData(this._url+"/get?userId="+id+passwd||"");
                if(data.message === null) return null;
                return new this._UserAPI(data);
            }
        }
        this.users = new UsersAPI(this.ip+":"+this.port);
        this.guilds = new GuildsAPI(this.ip+":"+this.port);
    }
    async check() {
        const data = await getData(this.ip+":"+this.port);
        return data.st;
    }
    stop() {
        this.server.close();
    }
}
class Memory {
    constructor(name = "DiscordDB", Client = null) {
        if(!name || typeof name !== "string") throw "Name not suitable";
        this.name = name;
        //if(!Client) throw "Client is not defined";
        globals.bot = Client;
        try {
            this._config = require(require.main.path.replace(/\\/gmi, "/")+`/${this.name}/config.json`);
            this._memberData = this._config.members = require(require.main.path.replace(/\\/gmi, "/")+`/${this.name}/Schems/members.js`);
            this._guildData = this._config.guilds = require(require.main.path.replace(/\\/gmi, "/")+`/${this.name}/Schems/guilds.js`); 
            this._userData = this._config.users = require(require.main.path.replace(/\\/gmi, "/")+`/${this.name}/Schems/users.js`); 

            if(this._guildData) this.setGuilds(this._guildData);
            if(this._userData) this.setUsers(this._userData);
            if(this._memberData) this.setMembers(this._memberData);
            this.setAnyData();
            
            if(this._config.autoSave.enable) this.setAutoSave(this._config.autoSave.time);
            if(this._config.backUp.enable) this.setBackUp(this._config.backUp.time);
            
            if(this._config.autoAdd) {
                Client.on('messageCreate', message => {
                    if(message.guild) {
                        if(!this.guilds.get(message.guild.id)) this.guilds.add(message.guild);
                        const memGuild = this.guilds.get(message.guild.id,false);
                        if(!memGuild.members.get(message.author.id)&&message.member) memGuild.members.add(message.member);
                        if(!this.users.get(message.author.id)&&message.author) this.users.add(message.author);
                    }
                });
                Client.on('guildMemberAdd', member => {
                    if(member.guild) {
                        if(!this.guilds.get(member.guild.id)) this.guilds.add(member.guild);
                        const memGuild = this.guilds.get(member.guild.id,false);
                        if(!memGuild.members.get(member.id)) memGuild.members.add(member);
                        if(!this.users.get(member.id)) this.users.add(member.user);
                    }
                });
            } 
        } catch (err) {
            this._config = {
                autoAdd: false,
                backUp: {
                    enable: false,
                    time: 3600000,
                    count: 2
                },
                autoSave: {
                    enable: false,
                    lastRefresh: Date.now(),
                    time: 60000*10
                }
            };
        }

        this.ServerAPI = ServerAPI;
        this.ClientAPI = ClientAPI;
    }
    get consoleClear() {
        const guilds = [],
        members = [],
        users = [];
        if(this.guilds) for (const key in this.guilds) {
            guilds.push(key);
            const guild = this.guilds[key];
            if(guild.members) for (const keys in guild.members) {
                members.push(keys);
            }
        } 
        if(this.users) for (const key in this.users) {
            users.push(key);
        }
        const text = "" +
        ` ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑` + "\n"+
        ` ┝━━┥ Name DB:-------> ${this.name}` + "\n"+
        ` ┝━━┥ Elements:------> ${guilds.length+members.length+users.length} count` + "\n"+
        ` ┝━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┥` + "\n"+
        ` ┝━━┥ Guilds:--------> ${guilds.length} count` + "\n"+
        ` ┝━━┥ Members:-------> ${members.length} count` + "\n"+
        ` ┝━━┥ Users:---------> ${users.length} count` + "\n"+
        ` ┝━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┥` + "\n"+
        ` ┝━━┥ BackUP: ${this._config.backUp.enable?"True":"False"}` + "\n"+
        ` ┝━━┥ BackUP Time: ${this._config.backUp.time}` + "\n"+
        ` ┝━━┥ BackUP Count: ${this._config.backUp.count}` + "\n"+
        ` ┝━━┥ AutoSave: ${this._config.autoSave.enable?"True":"False"}` + "\n"+
        ` ┝━━┥ AutoAdd: ${this._config.autoAdd?"True":"False"}` + "\n"+
        ` ┝━━┥ SaveTime: ${this._config.autoSave.time}` + "\n"+
        ` ┝━━┥ Schems Guilds: ${this._config.guilds?"Enabled":"None"}` + "\n"+
        ` ┝━━┥ Schems Members: ${this._config.members?"Enabled":"None"}` + "\n"+
        ` ┝━━┥ Schems Users: ${this._config.users?"Enabled":"None"}` + "\n"+
        ` ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙`;

        return text;
    }
    get console() {
        const guilds = [],
        members = [],
        users = [];
        if(this.guilds) for (const key in this.guilds) {
            guilds.push(key);
            const guild = this.guilds[key];
            if(guild.members) for (const keys in guild.members) {
                members.push(keys);
            }
        } 
        if(this.users) for (const key in this.users) {
            users.push(key);
        }
        const text = "" +
        ` ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑` + "\n"+
        ` ┝━━┥ Name DB:-------> \x1b[33m${this.name}\x1b[0m` + "\n"+
        ` ┝━━┥ Elements:------> \x1b[33m${guilds.length+members.length+users.length} count\x1b[0m` + "\n"+
        ` ┝━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┥` + "\n"+
        ` ┝━━┥ Guilds:--------> \x1b[33m${guilds.length} count\x1b[0m` + "\n"+
        ` ┝━━┥ Members:-------> \x1b[33m${members.length} count\x1b[0m` + "\n"+
        ` ┝━━┥ Users:---------> \x1b[33m${users.length} count\x1b[0m` + "\n"+
        ` ┝━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┥` + "\n"+
        ` ┝━━┥ BackUP: ${this._config.backUp.enable?"\x1b[32mTrue\x1b[0m":"\x1b[31mFalse\x1b[0m"}` + "\n"+
        ` ┝━━┥ BackUP Time: \x1b[33m${this._config.backUp.time}\x1b[0m` + "\n"+
        ` ┝━━┥ BackUP Count: \x1b[33m${this._config.backUp.count}\x1b[0m` + "\n"+
        ` ┝━━┥ AutoSave: ${this._config.autoSave.enable?"\x1b[32mTrue\x1b[0m":"\x1b[31mFalse\x1b[0m"}` + "\n"+
        ` ┝━━┥ AutoAdd: ${this._config.autoAdd?"\x1b[32mTrue\x1b[0m":"\x1b[31mFalse\x1b[0m"}` + "\n"+
        ` ┝━━┥ SaveTime: \x1b[33m${this._config.autoSave.time}\x1b[0m` + "\n"+
        ` ┝━━┥ Schems Guilds: ${this._config.guilds?"\x1b[32mEnabled\x1b[0m":"\x1b[31mNone\x1b[0m"}` + "\n"+
        ` ┝━━┥ Schems Members: ${this._config.members?"\x1b[32mEnabled\x1b[0m":"\x1b[31mNone\x1b[0m"}` + "\n"+
        ` ┝━━┥ Schems Users: ${this._config.users?"\x1b[32mEnabled\x1b[0m":"\x1b[31mNone\x1b[0m"}` + "\n"+
        ` ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙`;

        return text;
    }
    get clearData() {
        const newThis = {};
        _delete(newThis, this);
        if(newThis.guilds) {
            newThis.guilds = newThis.guilds.clearData;
            for (const key in newThis.guilds) {
                const guild = newThis.guilds[key];
                guild.members = guild.members.clearData;
            }
        }
        if(newThis.users) newThis.users = newThis.users.clearData;
        return newThis;
    }
    get clearSaveData() {
        const newThis = {};
        _delete(newThis, this);
        for (const key in newThis) {
            if(isFunction(newThis[key])) newThis[key] = "FNC-"+newThis[key].toString();
        }
        if(newThis.guilds) {
            newThis.guilds = newThis.guilds.clearData;
            for (const key in newThis.guilds) {
                const guild = newThis.guilds[key];
                for (const guildKey in guild) {
                    if(isFunction(guild[guildKey])) guild[guildKey] = "FNC-"+guild[guildKey].toString();
                }
                guild.members = guild.members.clearData;
                for (const memKey in guild.members) {
                    if(isFunction(guild.members[memKey])) guild.members[memKey] = "FNC-"+guild.members[memKey].toString();
                }
            }
        }
        if(newThis.users) newThis.users = newThis.users.clearData;
        for (const userKey in newThis.users) {
            if(isFunction(newThis.users[userKey])) newThis.users[userKey] = "FNC-"+newThis.users[userKey].toString();
        }
        return newThis;
    }
    _backUp() {
        const time = Date.now(),
        name = this.name,
        data = {},
        anyData = {},
        config = this._config;
        for (const key in this.clearData) {
            const element = this.clearData[key];
            if(["guilds", "users", "name"].includes(key)) data[key] = element;
            else anyData[key] = element;
        }
        fs.mkdirSync(`./${name}/_backUp/${time}`);
        fs.stat(`./${this.name}`, (err) => {
            if (!err) {
                fs.writeFileSync(`./${name}/_backUp/${time}/Memory.json`, JSON.stringify(data, null, '\t'));
                fs.writeFileSync(`./${name}/_backUp/${time}/AnyData.json`, JSON.stringify(anyData, null, '\t'));
                fs.writeFileSync(`./${name}/_backUp/${time}/config.json`, JSON.stringify(config, null, '\t'));
            }
            else if (err.code === 'ENOENT') {
                throw "No patch data!";
            }
        });
        fs.readdir(`./${name}/_backUp`, (err, files) => {
            const dirDellete = files.sort((a,b)=>a-b).slice(0,this._config.backUp.count*-1);
            for (const dir of dirDellete) fs.rmSync(`./${name}/_backUp/${dir}`, { recursive: true });
        });
    }
    setBackUp(args=60000*60) {
        switch(args) {
            case false:
                this._config.backUp.enable = false;
                clearInterval(this._BackUp);
                return;
            case true:
                this._config.backUp.enable = true;
                clearInterval(this._IntervalBack);
                if(this._config.backUp.time>=60000*60) this._IntervalBack = setInterval(() => {
                    this._backUp();
                }, this._config.backUp.time);
                return;
        }
        if(!isNaN(+args)) {
            if(+args<2000) throw "The time can only be more than 2000";
            this._config.backUp.time = +args;
            this._config.backUp.enable = true;
            clearInterval(this._IntervalBack);
            this._IntervalBack = setInterval(() => {
                this._backUp();
            }, this._config.backUp.time);
        }
    }
    setAutoSave(args=60000*10) {
        switch(args) {
            case false:
                this._config.autoSave.enable = false;
                clearInterval(this._Interval);
                return;
            case true:
                this._config.autoSave.enable = true;
                clearInterval(this._Interval);
                if(this._config.autoSave.time>=60000) this._Interval = setInterval(() => {
                    if(Date.now()-this._config.autoSave.lastRefresh<(this._config.autoSave.time-1000))this.save();
                }, this._config.autoSave.time);
                return;
        }
        if(!isNaN(+args)) {
            if(+args<2000) throw "The time can only be more than 2000";
            this._config.autoSave.time = +args;
            this._config.autoSave.enable = true;
            clearInterval(this._Interval);
            this._Interval = setInterval(() => {
                this.save();
            }, this._config.autoSave.time);
        }
    }
    async create() {
        return new Promise((resolve, reject) => {
            const name = this.name,
            memoryData = {name, guilds: {}, users: {}},
            configData = {
                autoAdd: false,
                backUp: {
                    enable: false,
                    time: 3600000,
                    count: 2
                },
                autoSave: {
                    enable: false,
                    lastRefresh: Date.now(),
                    time: 60000*10
                }
            };
            const startDB = () => {
                this._memberData = this._config.guilds = require(require.main.path.replace(/\\/gmi, "/")+`/${this.name}/Schems/guilds.js`);
                this._guildData = this._config.users = require(require.main.path.replace(/\\/gmi, "/")+`/${this.name}/Schems/users.js`);
                this._userData = this._config.members = require(require.main.path.replace(/\\/gmi, "/")+`/${this.name}/Schems/members.js`);

                if(this._guildData) this.setGuilds(this._guildData);
                if(this._userData) this.setUsers(this._userData);
                if(this._memberData) this.setMembers(this._memberData);
                this.setAnyData();
                
                if(this._config.autoSave.enable) this.setAutoSave(this._config.autoSave.time);
                if(this._config.backUp.enable) this.setBackUp(this._config.backUp.time);
                
                if(this._config.autoAdd||globals.bot) {
                    globals.bot.on('messageCreate', message => {
                        if(message.guild) {
                            if(!this.guilds.get(message.guild.id)) this.guilds.add(message.guild);
                            const memGuild = this.guilds.get(message.guild.id,false);
                            if(!memGuild.members.get(message.author.id)&&message.member) memGuild.members.add(message.member);
                            if(!this.users.get(message.author.id)&&message.author) this.users.add(message.author);
                        }
                    });
                    globals.bot.on('guildMemberAdd', member => {
                        if(member.guild) {
                            if(!this.guilds.get(member.guild.id)) this.guilds.add(member.guild);
                            const memGuild = this.guilds.get(member.guild.id,false);
                            if(!memGuild.members.get(member.id)) memGuild.members.add(member);
                            if(!this.users.get(member.id)) this.users.add(member.user);
                        }
                    });
                } 
            };
            function create() {
                fs.writeFileSync(`./${name}/Memory.json`, JSON.stringify(memoryData, null, '\t'));
                fs.writeFileSync(`./${name}/AnyData.json`, JSON.stringify({}, null, '\t'));
                fs.writeFileSync(`./${name}/config.json`, JSON.stringify(configData, null, '\t'));
                fs.writeFileSync(`./${name}/Schems/guilds.js`, `module.exports = guild => {`+"\n"+
                `    if(!guild) guild = {`+"\n"+
                `        name: "NULL Guild",`+"\n"+
                `        id: 12345,`+"\n"+
                `        ownerId: 12345`+"\n"+
                `    };`+"\n"+
                `    return  {`+"\n"+
                `        "name": guild.name,`+"\n"+
                `        "owner": guild.ownerId,`+"\n"+
                `        "id": guild.id,`+"\n"+
                `        members: {}`+"\n"+
                `    };`+"\n"+
                `};`);
                fs.writeFileSync(`./${name}/Schems/members.js`, `module.exports = member=>{`+"\n"+
                `    if(!member) member = {user:{username:"NULL Member"},id:"123",guild:{id:"123"}};`+"\n"+
                `    return {`+"\n"+
                `        id: member.id,`+"\n"+
                `        username: member.user.username,`+"\n"+
                `        guildId: member.guild.id`+"\n"+
                `    };`+"\n"+
                `};`);
                fs.writeFileSync(`./${name}/Schems/users.js`, `module.exports = user => {`+"\n"+
                `    if(!user) user = {`+"\n"+
                `        id: 123,`+"\n"+
                `        username: "NULL User",`+"\n"+
                `    };`+"\n"+
                `    return {`+"\n"+
                `        "name": user.username,`+"\n"+
                `        "id": user.id,`+"\n"+
                `    };`+"\n"+
                `};`);
            }
            fs.stat(`./${this.name}`, (err) => {
                if (!err) {
                    create();
                    startDB();
                    return resolve();	
                }
                else if (err.code === 'ENOENT') {
                    fs.mkdirSync(name);
                    fs.mkdirSync(`./${name}/_backUp`);
                    fs.mkdirSync(`./${name}/Schems`);
                    create();
                    startDB();
                    return resolve();
                }
                else reject(err);
            });
        });
    }
    save() {
        const name = this.name,
        data = {},
        anyData = {},
        config = this._config;
        const clearSaveData = this.clearSaveData;
        for (const key in clearSaveData) {
            const element = clearSaveData[key];
            if(["guilds", "users", "name"].includes(key)) data[key] = element;
            else anyData[key] = element;
        }
        this._config.autoSave.lastRefresh = Date.now();
        fs.stat(`./${this.name}`, (err) => {
            if (!err) {
                fs.writeFileSync(`./${name}/Memory.json`, JSON.stringify(data, null, '\t'));
                fs.writeFileSync(`./${name}/AnyData.json`, JSON.stringify(anyData, null, '\t'));
                fs.writeFileSync(`./${name}/config.json`, JSON.stringify(config, null, '\t'));

                //if(this._config.guilds) fs.writeFileSync(`./${name}/Schems/guilds.js`, `module.exports = ${this._config.guilds.toString()};`);
                //if(this._config.users) fs.writeFileSync(`./${name}/Schems/users.js`, `module.exports = ${this._config.users.toString()};`);
                //if(this._config.members) fs.writeFileSync(`./${name}/Schems/members.js`, `module.exports = ${this._config.members.toString()};`);
                
            }
            else if (err.code === 'ENOENT') {
                throw "No patch data!";
            }
        });
    }
    setAnyData() {
        const MemAny = require(require.main.path.replace(/\\/gmi, "/")+`/${this.name}/AnyData.json`);
        for (const key in MemAny) {
            if(typeof MemAny[key] == "string" && MemAny[key].slice(0,3)=="FNC") this[key] = stringToFunction(MemAny[key]);
            else this[key] = MemAny[key];
        } 
    }
    setGuilds(guildData) {
        const MemGuilds = require(require.main.path.replace(/\\/gmi, "/")+`/${this.name}/Memory.json`).guilds;
        if(guildData) this._config.guilds = guildData;
        if(!guildData) guildData = function(guild={id:"None",name:"None"}) {
            return {
                id: guild.id,
                name: guild.name,
                members: {}
            };
        };
        
        class Guilds {
            constructor(guildData, motherData) {
                this._scheme = guildData;
                this._motherData = motherData;
            }
            [Symbol.iterator]() {
                this._iter = {
                    Array: Object.values(this).filter(it=>it.id),
                    current: 0
                };
                return this;
            } 
            next() {
                if (this._iter.current < this._iter.Array.length) {
                    this._iter.current++;
                    return { done: false, value: this._iter.Array[this._iter.current-1]};
                } else {
                    return { done: true };
                }
            }
            update() {
                for (const key in this) {
                    if(key.slice(0,1) !== "_") {
                        const element = this[key];
                        for (let index = 0; index < arguments.length; index++) {
                            const keys = arguments[index];
                            element[keys] = this._scheme(element.cache)[keys];
                        }
                    }	
                }
                return this;
            }
            get(id, clear = false) {
                if(!id) throw "id is null";
                if(clear && this[id]) return this[id].clearData;
                else return this[id]||null;
            }
            add(guilde) {
                if(!guilde) throw "guild is null";
                const guild = this._scheme(guilde);
                this.set(guild);
                return guild;
            }
            set(guilde) {
                this[guilde.id] = new Guild(guilde, this);
                this._motherData.setMembers(this._motherData._memberData, this[guilde.id]);
                return this[guilde.id];
            }
            get clearData() {
                const newThis = {};
                _delete(newThis, this);
                for (const key in newThis) 
                    if(Object.hasOwnProperty.call(newThis, key)) newThis[key] = newThis[key].clearData;
                return newThis;
            }
        }

        class Guild {
            constructor(guilde, motherData) {
                for (const key in guilde) this[key] = guilde[key];
                this._scheme = motherData._scheme;
            }
            set members(value) {
                this._members = value;
            }
            get members() {
                return this._members;
            }
            update() {
                for (let index = 0; index < arguments.length; index++) {
                    const keys = arguments[index];
                    this[keys] = this._scheme(this.cache)[keys];
                }
                return this;
            }
            get clearData() {
                const newThis = {};
                _delete(newThis, this);
                newThis.members = this.members;
                return newThis;
            }
            async fetch() {
                return await globals.bot?.guilds?.fetch(this.id);
            }
            get cache() {
                return globals.bot?.guilds?.cache?.get(this.id);
            }
            get cacheOne() {
                if(globals.bot?.guilds?.cache?.get(this.id)) return globals.bot?.guilds?.cache?.get(this.id);
                else return globals.bot?.guilds?.fetch(this.id);
            }
        }

        if(!this.guilds) this.guilds = new Guilds(guildData, this);

        const serv = guildData();
        for(let keys in MemGuilds) { //Обновлятель памяти
            const origin = MemGuilds[keys];
            UpdateCreate(origin, serv);
            UpdateDelete(origin, serv);
            for (const key in origin) {
                const element = origin[key];
                if(typeof element == "string" && element.slice(0,3)=="FNC") origin[key] = stringToFunction(element);
            }
            this.guilds.set(origin);
        }
    }
    setUsers(userData) {
        const MemUsers = require(require.main.path.replace(/\\/gmi, "/")+`/${this.name}/Memory.json`).users;

        if(userData) this._config.users = userData;
        if(!userData) userData = function(user={id:"None",username:"None"}) {
            return {
                id: user.id,
                username: user.username
            };
        };
            
        class Users {
            constructor(userData, motherData) {
                this._scheme = userData;
                
            }
            [Symbol.iterator]() {
                this._iter = {
                    Array: Object.values(this).filter(it=>it.id),
                    current: 0
                };
                return this;
            } 
            next() {
                if (this._iter.current < this._iter.Array.length) {
                    this._iter.current++;
                    return { done: false, value: this._iter.Array[this._iter.current-1]};
                } else {
                    return { done: true };
                }
            }
            update() {
                for (const key in this) {
                    if(key.slice(0,1) !== "_") {
                        const element = this[key];
                        for (let index = 0; index < arguments.length; index++) {
                            const keys = arguments[index];
                            element[keys] = this._scheme(element.cache)[keys];
                        }
                    }	
                }
                return this;
            }
            get(id, clear = false) {
                if(!id) throw "id is null";
                if(clear && this[id]) return this[id].clearData;
                else return this[id]||null;
            }
            add(usere) {
                if(!usere) throw "guild is null";
                const guild = this._scheme(usere);
                this.set(guild);
                return guild;
            }
            set(usere) {
                this[usere.id] = new User(usere, this);
                return this[usere.id];
            }
            get clearData() {
                const newThis = {};
                _delete(newThis, this);
                for(const key in newThis) 
                    if(Object.hasOwnProperty.call(newThis, key)) newThis[key] = newThis[key].clearData;
                return newThis;
            }
        }

        class User {
            constructor(usere, motherData) {
                for (const key in usere) this[key] = usere[key];
                
            }
            update() {
                for (let index = 0; index < arguments.length; index++) {
                    const keys = arguments[index];
                    this[keys] = this._scheme(this.cache)[keys];
                }
                return this;
            }
            async fetch() {
                return await globals.bot.users.fetch(this.id);
            }
            get clearData() {
                const newThis = {};
                _delete(newThis, this);
                return newThis;
            }
            get cache() {
                return globals.bot.users.cache.get(this.id);
            }
            get cacheOne() {
                if(globals.bot.users.cache.get(this.id)) return globals.bot.users.cache.get(this.id);
                else return globals.bot.users.fetch(this.id);
            }
        }

        if(!this.users) this.users = new Users(userData, this);

        const user = userData();
        for(let keys in MemUsers) { //Обновлятель памяти
            const origin = MemUsers[keys];
            UpdateCreate(origin, user);
            UpdateDelete(origin, user);
            for (const key in origin) {
                const element = origin[key];
                if(typeof element == "string" && element.slice(0,3)=="FNC") origin[key] = stringToFunction(element);
            }
            this.users.set(origin);
        }
    }
    setMembers(memberData, guild) {
        this._memberData = memberData;
        if(memberData) this._config.members = memberData;
        if(!memberData) memberData = function(member={id:"None",user:{username:"None"},guild:{id:"123"}}) {
            return {
                id: member.id,
                username: member.user.username,
                guildId: member.guild.id
            };
        };

        class Members {
            constructor(guildData, motherData, startMembers) {
                this._scheme = guildData;
                this._old = startMembers;
            }
            [Symbol.iterator]() {
                this._iter = {
                    Array: Object.values(this).filter(it=>it.id),
                    current: 0
                };
                return this;
            } 
            next() {
                if (this._iter.current < this._iter.Array.length) {
                    this._iter.current++;
                    return { done: false, value: this._iter.Array[this._iter.current-1]};
                } else {
                    return { done: true };
                }
            }
            update() {
                for (const key in this) {
                    if(key.slice(0,1) !== "_") {
                        const element = this[key];
                        for (let index = 0; index < arguments.length; index++) {
                            const keys = arguments[index];
                            element[keys] = this._scheme(element.cache)[keys];
                        }
                    }	
                }
                return this;
            }
            get(id, clear = false) {
                if(!id) throw "id is null";
                if(clear && this[id]) return this[id].clearData;
                else return this[id]||null;
            }
            add(membere) {
                if(!membere) throw "member is null";
                const guild = this._scheme(membere);
                this.set(guild);
                return guild;
            }
            set(membere) {
                if(membere.id == "123") return;
                this[membere.id] = new Member(membere, this);
                return this[membere.id];
            }
            get clearData() {
                const newThis = {};
                _delete(newThis, this);
                for (const key in newThis) 
                    if(Object.hasOwnProperty.call(newThis, key)) newThis[key] = newThis[key].clearData;
                return newThis;
            }
        }

        class Member {
            constructor(membere, motherData) {
                for (const key in membere) this[key] = membere[key];
                
                this._scheme = motherData._scheme;
            }
            update() {
                for (let index = 0; index < arguments.length; index++) {
                    const keys = arguments[index];
                    this[keys] = this._scheme(this.cache)[keys];
                }
                return this;
            }
            async fetch() {
                const guild = globals.bot?.guilds?.cache?.get(this.guildId);
                if(guild && guild.available)
                return await guild.members.fetch(this.id);
            }
            get clearData() {
                const newThis = {};
                _delete(newThis, this);
                return newThis;
            }
            get cache() {
                const guild = globals.bot?.guilds?.cache?.get(this.guildId);
                if(guild && guild.available) return guild.members.cache.get(this.id);
            }
            get cacheOne() {
                const guild = globals.bot?.guilds?.cache?.get(this.guildId);
                if(guild && guild.available) if(guild.members.cache.get(this.id)) return guild.members.cache.get(this.id);
                else guild.members.fetch(this.id);
            }
        }

        const member = memberData();
        if(guild) {
            guild._members = new Members(memberData, this, guild.members);
            for (const key in guild._members._old) {
                const origin = guild._members._old[key];
                UpdateCreate(origin, member);
                UpdateDelete(origin, member);
                for (const key in origin) {
                    const element = origin[key];
                    if(typeof element == "string" && element.slice(0,3)=="FNC") origin[key] = stringToFunction(element);
                }
                guild._members.set(origin);	
            }
            delete guild._members._old;
        }
        /*else for(let keys in this.guilds) { //Обновлятель памяти
            if(keys.slice(0,1) !== "_") {
                const origin = this.guilds[keys];		
                origin._members = new Members(memberData, this, origin.members);
                for (const key in origin._members._old) {
                    const element = origin._members._old[key];
                    UpdateCreate(element, member);
                    UpdateDelete(element, member);
                    origin._members.set(element);	
                }
                delete origin._members._old;
            }
        }*/
    }
}
Memory.ServerAPI = ServerAPI;
Memory.ClientAPI = ClientAPI;
module.exports = Memory;